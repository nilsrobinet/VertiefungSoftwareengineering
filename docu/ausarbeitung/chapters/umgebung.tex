\chapter{Entwicklungsumgebung}

Für das Projekt sollte eine \acf{CI/CD} Pipline angelegt werden. Zu diesem Zweck wird ein Build Server in einer \acf{VM} gestartet. Der Code soll in einer in einer Versionsverwaltungs eingecheckt werden, um Änderungen nachvollziehbar zu machen und Zusammenarbeit am Code zu vereinfachen.  

\section{Werkzeuge und Anwendungen}

Der Code des projektes wird mit der Versionsverwaltungssoftware GIT gemanaged (mehr zur git Strategie in \autoref{chap:git-strat}). Um das remote repository zu managen wird Github als Frontend eingesetzt. Die \ac{CI/CD} Pipeline wird durch den open source Build-Server Jenkins gemanaged. Die Build-Toolchain wird in einem Docker-Container bereit gestellt. Der Build-Server läuft in einer \ac{VM}. Als Virtualisierungslösung wurde QEMU/KVM ausgeählt. Die Builds werden mittels CMake und Bash-Scipten Konfiguriert.

\section{Build-Server Setup}

Als Guest-Beriebsystem wurde sich für Arch Linux entschieden, da von diesem Betriebsystem bereits fertig vorgebaute \ac{VM} images bereit gestellt werden (\url{https://gitlab.archlinux.org/archlinux/arch-boxes/-/packages}). Unter anderem wird ein qcow2 image das in der Virtualisierungsumgebung QEMU eingesetzt werden kann bereit gestellt.
In der \ac{VM} wird ein Jenkins build server installiert, der die CI/CD pipline bedient.

\subsection{Installation}

Die Build-Server \ac{VM} wurde auf ein Arch Linux System erstellt, einzellne Schritte, insbesondere wenn eine Packetverwaltungssoftware eingesetzt wird können sich zwischen den verschiedenen Betriebsystemen unterscheiden.
Zur erstellung und installation wurden folgende Schritte durch geführt:

\begin{enumerate}
    \item Datenträgerabbild herunter laden:\\
        \lstinline[language=sh]!wget -O build_server.qcow2 https://gitlab.archlinux.org/archlinux/arch-boxes/-/package_files/6852/download!
    \item Virtuelle Machine Starten:\\
    \lstinline[language=sh]!qemu-system-x86_64 -m 4G -smp 4 -enable-kvm\! \\
    \lstinline[language=sh]!                   -nic user,hostfwd=tcp::60022-:22,hostfwd=tcp::8090-:8090\ !\\
    \lstinline[language=sh]!                   build_server.qcow2!\\
    Der Benutzername und das Standartpasswort lauten: arch/arch; Man kann sich nun mittels ssh mit der \ac{VM} verbinden:\\
    \lstinline[language=sh]!ssh arch@localhost -p 60022!\\
    \item Jenkins installieren:\\
    \lstinline[language=sh]!pacman -Syu !\\
    \lstinline[language=sh]!pacman -S fontconfig!\\
    \lstinline[language=sh]!pacman -S freetype2!\\
    \lstinline[language=sh]!pacman -S jenkins!\\
    \lstinline[language=sh]!pacman -S docker!\\
    \lstinline[language=sh]!pacman -S git!\\
    \lstinline[language=sh]!systemctl enable jenkins!\\
    \lstinline[language=sh]!systemctl enable docker!\\
    \lstinline[language=sh]!systemctl start jenkins!\\
    \lstinline[language=sh]!systemctl start docker!\\
    \lstinline[language=sh]!sudo usermod -aG docker jenkins!\\
    \item Nach der installation kann über den Webrowser auf dem Host Beriebsystem unter der Addresse http://localhost:8090 auf die jenkins installation zu gegriffen werden. Im initialen Setup-dialog muss ausgewählt werden ob dieStandar-Plugins installiert werden sollen, hier sollte mit ja geantwortet werden, und ein Admin Benutzer angelegt werden. Danach landet man im Haupmenu der Jenkins installation.

Zusätzlich wird noch das Plugin \glqq Docker Pipeline\grqq{} benötigt, das es ermöglicht in docker images zu bauen.
\end{enumerate}

\subsection{Projekt einrichtung}

Unter dem Punkt \glqq new job\grqq{} wird ein neuer Multibranch Pipeline Job angelegt und Konfiguriert. Als Branch Source wird das github Repo dieses Projekts angegeben. Damit jenkins auf das Projekt zu greifen kann müsen noch Github credentials eingrtragen werden.

Damit Jenkins Änderungen zeitnah erkennt wir ein periodischer Trigger mit einem Intervall von einer Minute eingestellt. Danach ist das Projekt fertig konfiguriert und kann benutzt werden.

Die Build und Deployment stages werden durch das im Repositroy eingecheckte Jenkinsfile konfgiuriert. Der build findet in einem Docker-Container statt der durch ein Dockerfile, das ebenfalls eingecheckt ist, erstellt wird. Das docker image wird durch Jenkins gemanaged, Jenkins kümmert sich auch darum das Dockerimage beiÄnderungen am Dockerfile neu zu generieren.

\subsection{Pipeline Konfiguration}

Die Build-/Deployment-Pipeline wird durch die Datei Jenkisfile, die im Root-Verzeichniss des Projekts liegt, konfigiert. Für jeden Branch kann dabei eine andere Konfiguration in der zugehörigen Jenkisfile Datei angelegt werden, so können Entwickler auf ihrem Branch ungestörrt neue Features, die Änderungen and der CI/CD-Pipeline nach sich ziehen, hoch bringen ohne andere Branches wie den develop oder main Branch zu beeinflussen.
Im Unterordner \lstinline{build_scripts} liegen Script-Dateien welche in den einzelnen Schritten der Pipeline aufgerufen werden. Mit Hilfe dieser Scripte werden dann die eigentlichen Builds und Deployments durchgeführt.

Jenkins wertet die Jenkinsfile Datei automatisch aus und führt die darin beschriebenen Schritte durch. Die Datei ist hirarchich aufgebaut. In der obersten Ebene wird durch den Key \glqq pipeline\grqq{} festgelegt, das eine Pipeline beschrieben werden soll. in der Ebene darunter wird unter dem Key \glqq  agent\grqq{} festgelget, wo das Projekt gebaut werden soll und welche voraussetzungen die Build-Agents mit bringen müssen. Da keine anderen Build agents angelegt wurden, wird das Projekt direkt auf dem Jenkins server gebaut, daher wird hier nur Festgelegt, dass das Projekt in einem Docker Container gebaut werden soll. Der Docker Container wird durch das Dockerfile, welches ebenfalls im Root-Verzeichniss des Projekts eingecheckt ist erstellt. Da Jenkins nur das Dockerfile bekannt gemacht wurde, übernimmt Jenkins das Managemnt der Images, das Bedeutet unter anderem, dass Jenkins automatisch detektiert ob sich das Dockerfile geändert hat und ob ein neues Image gebaut werden muss.


Unter dem Key \glqq  stages\grqq{} werden die Einzelschritte der Pipeline fest gelegt. In diesem Fall sind das vier Schritte: 
\begin{enumerate}
    \item{Build} In der Build-Stage wird das Script makeC.sh aufgerufen, das mit Hilfe des tools CMake (siehe \autoref{chap:tools}) die C++ und Cython Komponenten des Projekts baut und in das Verzeichnis bin installiert. Das Script wird anstelle von Jenkins Boardmitteln verwendet, das so lokal und auf dem Buildserver das gleiche Skript genutzt werden kann um das Proekt zu bauen.
    \item{Test} In dieser Stage werden verschiedene Tests mit den Tools ctest (C Unit tests) und pytest (Python tests) und pylint (Python Linting) ausgeführt. Die Ergbnisse werden im junit-xml Format gespeichert, dammit sie später im post-Teil der Pipeline ausgewertet werden können.
    \item{Docu} In dieser Stage wird die Dokumentation generiert. Dazu wird das Script makedoc.sh genutzt, welches diese Ausarbeitung sowie die Doxygen-Dokumentation der C++ Komponenten generiert.  
    \item{Deploy} In dieser Stage wird das fertig kompilierte und installierte Programm ausgeliefert und gestartet. Hierzu wird das Script deploy.sh verwendet. 
    In der Deployment-Stage wird eine \glqq when\grqq{} Bedingung eingesetzt um zu verhindern, dass andere Branches als der main-Branch in das Produktiv-System deployt werden.  
\end{enumerate}

Der Key \glqq post\grqq{} beschreibt was nach dem Build und Deploy geschehen soll, dazu gehört das Speichern von artifakten, die behalten werden sollen und das auswerden von Testergebnissen.

\lstinputlisting[language=json]{../../Jenkinsfile}

\subsection{Buildumgebung}
Die Buildumgebung wird in einem Docker Container bereitgestellt. Das Docker Image wird durch ein Dockerfile erzeugt:

\lstinputlisting[language=bash]{../../Dockerfile}

Das Image Basiert auf einem Ubuntu Image in das zusätzlich alle Tools installiert werden die im Build prozess benötigt werden.

Die scripte die zum Bauen verwendet werden liegen im Verzeichnis \glqq build\_scripts\grqq{}. In diesem Verzeichnis liegen auch Scripte die das lokale Arbeiten vereinfachen sollen: Unter Anderem liegen hier scripte die das Bauen des Dockerimages automatisieren und ein Skipt das den Container interaktiv startet und das Repository mountet.
